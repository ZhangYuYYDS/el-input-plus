# 二次封装el-input

三个问题：

1. 属性事件，就是继承**使用的组件（父组件）**的的属性和事件
2. 插槽
3. ref，主要是用于能够调用**封装的组件（子组件）**实例上的属性和方法
4. 我自己有个疑问，就是为什么二次封装都需要用一个div标签包裹着，而不能直接用element-plus的组件，举例说明：
```
<div class="myinput">
    <el-input></el-input>
  </div>
</template>
```
解答：

- 因为element-plus组件通常会应用一些样式，并做了一些布局方面的设计，这些设计可能与自己的项目样式和布局产生冲突，不符合我的需求。
- 通过将element-plus的组件放在一个div中，可以更方便的控制其样式和布局。可以在这个div上应用自己的类名或样式，或者添加额外的元素来实现自定义的外观和行为，而不会影响到element-plus组件本身
- 另外，通过在div中包裹element-plus组件，也可以更方便的对组件进一步的封装或扩展。可以在这个包裹的div上添加额外的事件监听器、指令或者其他功能，满足特定的需求**



# 属性事件

需要使用到`attrs`属性，这个属性的作用是获取到父组件传递过来的属性，却没有被该组件声明为props或emits的属性。比如最常见的class、style和id等。

会发现两个问题：
1. attrs在vue3中可以获取到属性+事件
2. 透传的的属性会默认自动添加到根元素上，也就是上述例子的`<div class=”myinput”>` 

- 这就是我们要解决的第一个问题：**属性事件**，我们需要将透传过来的属性要添加到`<el-input></el-input>` 上，而不是包裹input组件的`div`标签上。

- 解决方案很简单，只需要使用v-bind，将attrs绑定到el-input上就可以了

```html
<template>
  <div class="myinput">
    <el-input v-bind="attrs"></el-input>
  </div>
</template>
```

# 插槽
我们封装的这些ui组件可能会带插槽，而且可能带的还不止一个，例如input就有四个插槽，所以这样就有几个问题：

1. 插槽里面写什么呢？因为插槽是由外面传递过来的决定的
2. 传递过去的插槽要对应
3. 考虑作用域插槽
4. 假如有一个功能是要根据传递过来的插槽数量执行一些功能，就不能把插槽全部写上了，要传过来几个写几个，可以通过vue提供的另一个属性，slots可以获得传递过来的所有插槽。然后遍历这个对象即可。


# ref
因为ref是没有转发的，所以我们单纯的写的ref拿到的是我们写的组件的引用，而拿不到第三方库el-input的引用。所以现在要解决的问题就是要让ref可以拿到的是el-input的引用。

我们可以将el-input组件暴露的东西，全部提取到MyInput这个组件，这样我们就能拿到了el-input组件上的所有属性和方法，可以使用vue3的`defineExpose` 暴露属性。

```jsx
defineExpose({
  elInp
})
```

